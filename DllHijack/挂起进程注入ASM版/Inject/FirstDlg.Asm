.386
.model flat, stdcall  ;32 bit memory model
option casemap :none  ;case sensitive

include FirstDlg.inc

.code

start:
	invoke GetModuleHandle,NULL
	mov		hInstance,eax

    invoke InitCommonControls
	invoke DialogBoxParam,hInstance,IDD_INJECT,NULL,addr DlgProc,NULL
	invoke ExitProcess,0

;########################################################################

DlgProc proc hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
	mov 		eax,hWin
	mov             g_hWnd,eax
	mov		eax,uMsg
	.if eax==WM_INITDIALOG

	.elseif eax==WM_COMMAND
		mov eax, wParam
		.if eax == BTN_INJECT
			invoke InjectCode
		.elseif eax == IDC_BTN1
		        invoke MyFreeMem
		.endif
	.elseif eax==WM_CLOSE
		invoke EndDialog,hWin,0
	.else
		mov		eax,FALSE
		ret
	.endif
	mov		eax,TRUE
	ret

DlgProc endp

begin_label: 
	push 12345678h                          ;push到栈中占坑用，存放ret后额的返回地址
        pushfd					;保存标志位
        pushad					;保存寄存器
	call $+5  ;重定位			;重定位代码，获取目标进程中的地址
FIXADDR:
	pop ebp
	sub ebp, FIXADDR			;求目标进程与注入中虚拟地址的差值，用于计算变量实际地址

	
	lea eax, [ebp + offset g_szDllPath]     ;DLL的路径
	push eax
	
	mov eax, [ebp + offset g_pfnLoadLibrary]
	call eax				;调用API
	popad					;恢复寄存器
	popfd					;恢复标志位
	ret
	g_pfnLoadLibrary DWORD 0
	g_szDllPath db 256 dup(0)
end_label:


InjectCode proc 
	LOCAL @hCalc:HWND
	LOCAL @dwPid :dword
	LOCAL @dwTid:dword
	LOCAL @hProcess :HANDLE
	LOCAL @lpBuff :PVOID
	LOCAL @hKernel32:HANDLE
	LOCAL @oldProtect:DWORD
	LOCAL @lpLoadLibrary:PVOID
	LOCAL @dwProcessID:dword
	LOCAL @dwThreadID:dword
	LOCAL @te32:THREADENTRY32 
	LOCAL @hThreadSnap:HANDLE
	LOCAL @hThread:HANDLE
	LOCAL @Context:CONTEXT 
	LOCAL @Si:STARTUPINFO
	LOCAL @Pi:PROCESS_INFORMATION
	
	invoke RtlZeroMemory,addr @Si,sizeof STARTUPINFO
	invoke RtlZeroMemory,addr @Pi,sizeof PROCESS_INFORMATION
	mov @Si.wShowWindow , SW_SHOWDEFAULT
	mov @Si.cb,sizeof PROCESS_INFORMATION
	
	
	invoke LoadLibrary, addr g_szKernel32
	mov @hKernel32, eax
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szLoadLibrary,offset g_err,MB_OK
	    ret
	.endif
	
	
	invoke GetProcAddress, @hKernel32, addr g_LoadLibrary
	mov @lpLoadLibrary, eax
	
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szGetProcAddress,offset g_err,MB_OK
	    ret
	.endif
	
	
	;修改内存保护属性
	invoke VirtualProtect, addr begin_label,  end_label -  begin_label, \
			PAGE_EXECUTE_READWRITE, addr @oldProtect
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szVirtualProtect,offset g_err,MB_OK
	    ret
	.endif
	
	mov eax, @lpLoadLibrary		
	mov g_pfnLoadLibrary, eax
	
	;获取窗口名，DLL路径
	invoke GetDlgItemText, g_hWnd,IDC_EDT1,offset g_szProcessName,256
	invoke GetDlgItemText, g_hWnd,IDC_EDT2,offset g_szDllPath,256
		
	invoke FreeLibrary,@hKernel32
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szFreeLibrary,offset g_err,MB_OK
	    ret
	.endif
	
	;以挂起的进程的方式创建进程
	invoke CreateProcess,offset g_strExePath,NULL,NULL,NULL,FALSE,CREATE_SUSPENDED,\
						NULL,NULL,addr @Si,addr @Pi
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szCreateProcess,offset g_err,MB_OK
	    ret
	.endif
	
	mov eax,@Pi.hProcess
	mov @hProcess,eax
	mov g_hProcess,eax
	
	mov eax,@Pi.hThread
	mov @hThread,eax
	

	;申请内存
	invoke VirtualAllocEx, @hProcess, NULL, 1000h, MEM_COMMIT, PAGE_EXECUTE_READWRITE
	mov @lpBuff, eax
	mov g_lpBuff,eax
	mov g_szAddr,eax
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szVirtualAllocEx,offset g_err,MB_OK
	    ret
	.endif
	
	
	;写入内存
	invoke WriteProcessMemory,@hProcess, @lpBuff, \
		addr begin_label, end_label - begin_label, NULL
	;check
	.if eax == 0
	    invoke MessageBox,NULL,offset g_szWriteProcessMemory,offset g_err,MB_OK
	    ret
	.endif
	

	
	mov @Context.ContextFlags,CONTEXT_FULL
	invoke GetThreadContext,@hThread,addr @Context
	.if eax == 0
	    invoke MessageBox,NULL,offset g_szGetThreadContext,offset g_err,MB_OK
	    ret
	.endif
	
	push ecx
	mov ecx,@Context.regEip
	mov g_pOldEip,ecx
	pop ecx
	
	mov eax,@lpBuff
	mov @Context.regEip,eax

	
	
	
	mov eax,@lpBuff
	add eax,1
	
	;写入内存
	invoke WriteProcessMemory,@hProcess, eax, \
		offset g_pOldEip,4, NULL
	;check
	.if eax == 0
	    invoke MessageBox,NULL,offset g_szWriteProcessMemory,offset g_err,MB_OK
	    ret
	.endif
	
	
	
	invoke SetThreadContext,@hThread,addr @Context
	
	.if eax == 0
	    invoke MessageBox,NULL,offset g_szSetThreadContext,offset g_err,MB_OK
	    ret
	.endif
	
	invoke ResumeThread,@hThread
	.if eax == -1
	    invoke MessageBox,NULL,offset g_szResumeThread,offset g_err,MB_OK
	    ret
	.endif

	
	
	;修改完一次过后需要再次修改最开始的状态
	invoke VirtualProtect, addr begin_label,  end_label -  begin_label, \
			@oldProtect, addr @oldProtect
	;check
	.if eax == NULL
	    invoke MessageBox,NULL,offset g_szVirtualProtect,offset g_err,MB_OK
	    ret
	.endif
	
	
	
	ret
    
InjectCode endp

MyFreeMem proc
	;释放内存
	invoke VirtualFreeEx,g_hProcess, g_lpBuff, 0,MEM_RELEASE
	;check
	.if eax == 0
	    invoke MessageBox,NULL,offset g_szVirtualFreeEx,offset g_err,MB_OK
	    ret
	.endif
	
	ret

MyFreeMem endp
end start
